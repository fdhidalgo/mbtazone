% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adjacency.R
\name{build_adjacency}
\alias{build_adjacency}
\title{Build Adjacency Graph from Parcel Data}
\usage{
build_adjacency(parcels, quiet = FALSE)
}
\arguments{
\item{parcels}{An sf object containing parcel polygons}

\item{quiet}{Logical indicating whether to suppress progress messages
(default: FALSE)}
}
\value{
A list of integer vectors representing the adjacency graph:
\itemize{
\item Element \code{i} contains indices of all parcels adjacent to parcel \code{i}
\item Uses 1-based indexing (R convention)
\item Isolated parcels have empty integer vectors
\item The adjacency relationship is symmetric: if \code{j} is in \code{adj[[i]]},
then \code{i} is in \code{adj[[j]]}
}
}
\description{
Constructs an adjacency graph from parcel spatial data using rook adjacency
(parcels must share an edge, not just a corner). This produces more robust
contiguity relationships than queen adjacency for zoning applications.
}
\details{
\strong{Rook vs Queen Adjacency:}

This function uses \strong{rook adjacency} via \code{sf::st_relate()} with the
DE-9IM pattern \code{"F***1****"}:
\itemize{
\item Rook: Parcels must share a boundary (edge intersection)
\item Queen: Parcels can touch at a single point (corner)
}

Rook adjacency is more robust for MBTA zoning applications because:
\itemize{
\item Avoids fragile single-point connections that may violate contiguity intent
\item More conservative definition aligns with legal contiguity requirements
\item Reduces risk of artificial corridors through corner-touch connections
}

\strong{Performance:}
\itemize{
\item Complexity: O(nÂ²) worst case, but typically much faster for real parcels
\item Sparse representation: Returns adjacency list, not dense matrix
\item For large municipalities (>5000 parcels): ~10-30 seconds
\item Results can be cached in mbta_map object for reuse
}

\strong{Edge Cases:}
\itemize{
\item Isolated parcels (no neighbors): Returns empty integer vector \code{integer(0)}
\item Invalid geometries: Detected and reported with warning
\item Self-loops: Not included in adjacency lists
}
}
\examples{
\dontrun{
# Load municipality parcel data
parcels <- load_municipality(
  "inst/extdata/parcels/57_CHELSEA_basic.zip",
  community_name = "Chelsea"
)

# Build adjacency graph
adj <- build_adjacency(parcels)

# Examine adjacency for first parcel
neighbors <- adj[[1]]
cat("Parcel 1 has", length(neighbors), "neighbors\n")

# Verify symmetry
stopifnot(all(sapply(seq_along(adj), function(i) {
  all(sapply(adj[[i]], function(j) i \%in\% adj[[j]]))
})))
}

}
