% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/smc_particle.R
\name{add_parcel_to_particle}
\alias{add_parcel_to_particle}
\title{Add Parcel to Particle (Tier 1 Update)}
\usage{
add_parcel_to_particle(particle, parcel_id, map, proposal_prob)
}
\arguments{
\item{particle}{A ParticleState object}

\item{parcel_id}{Integer index of parcel to add (row in map$data)}

\item{map}{An mbta_map object}

\item{proposal_prob}{Probability of proposing this parcel addition
(normalized proposal weight for importance sampling)}
}
\value{
Updated ParticleState object with new parcel added and running
sums updated
}
\description{
Add a parcel to the particle's zone and update all running sums. This
performs the Tier 1 update operation: O(1) arithmetic to increment totals
and decrement remaining capacity/area in the connected component.
}
\details{
\subsection{Tier 1 Operations (O(1) each)}{

This function performs the following updates:
\enumerate{
\item Add parcel to zone: \code{parcel_ids <- c(parcel_ids, parcel_id)}
\item Increment totals: \verb{total_capacity += capacity_parcel}
\item Decrement remaining: \verb{remaining_capacity -= capacity_parcel}
\item Update proposal path: \verb{log_proposal_path += log(proposal_prob)}
\item Increment step counter: \verb{n_steps += 1}
}

All operations are simple arithmetic, ensuring O(1) cost per propagation step.
}

\subsection{Station Area Handling}{

If the map has precomputed station attributes (\code{station_area_sf} column),
uses area-weighted station capacity. Otherwise uses binary indicator
(\code{in_station_area} column).
}

\subsection{NA Handling}{

Missing capacity or area values are treated as 0 for aggregation. This is
conservative for infeasibility checking (won't falsely kill particles).
}
}
\examples{
\dontrun{
# Initialize particle
particle <- new_particle_state(seed_id, chelsea_map)

# Get boundary parcels
boundary <- get_boundary_parcels(particle, chelsea_map)

# Add a boundary parcel
next_parcel <- sample(boundary, 1)
proposal_prob <- 1 / length(boundary)  # Uniform proposal
particle <- add_parcel_to_particle(particle, next_parcel, chelsea_map, proposal_prob)

# Check updated state
print(particle$n_parcels)  # Should be 2
print(particle$total_capacity)  # Incremented
}

}
\seealso{
\code{\link{new_particle_state}}, \code{\link{check_infeasibility}}
}
