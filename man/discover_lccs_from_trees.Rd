% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mcmc_spanning_tree.R
\name{discover_lccs_from_trees}
\alias{discover_lccs_from_trees}
\title{Discover LCCs via spanning tree enumeration (optimized)}
\usage{
discover_lccs_from_trees(
  parcel_graph,
  constraints,
  n_trees = 500L,
  forbidden_parcels = NULL,
  max_discovery_capacity = NULL,
  verbose = TRUE
)
}
\arguments{
\item{parcel_graph}{igraph parcel graph with capacity/area attributes}

\item{constraints}{MBTA constraints list (min_capacity, min_area, min_density)}

\item{n_trees}{Number of spanning trees to sample (default 500)}

\item{forbidden_parcels}{Optional character vector of parcels to exclude from LCCs}

\item{max_discovery_capacity}{Optional upper bound on LCC capacity for discovery.
LCCs above this are skipped. Default: min_capacity * DISCOVERY_CAPACITY_MULTIPLIER.}

\item{verbose}{Print progress (default TRUE)}
}
\value{
List with:
\itemize{
\item discovered_lccs: data.table with lcc_key, parcel_ids (list col), capacity, area, tree_count
\item n_trees_sampled: number of trees successfully sampled
\item n_trees_failed: number of trees that failed to build
\item total_cuts_found: total number of valid cuts found (before deduplication)
\item unique_lccs_found: number of unique LCCs after deduplication
}
}
\description{
Samples uniform random spanning trees and enumerates all valid LCC cuts.
"Valid" means the cut component can serve as an LCC candidate (meets area,
density, and min_lcc_capacity thresholds). LCC candidates need not be
standalone-feasible; secondaries may supply capacity in the final plan.
This is much more efficient than MCMC exploration for populating an LCC library.
}
\details{
Optimizations:
\itemize{
\item Uses igraph::sample_spanning_tree() (C-level Wilson's algorithm)
\item Precomputes invariant data (capacity, area, forbidden) once
\item Computes DFS metadata once per tree for O(k) cut extraction
\item Uses igraph::bfs() for C-level traversal in aggregates
}
}
